#### 1、Java里常见的数据结构都有哪些以及特征

- 数组

​        数组是最常用的数据结构，数组的特点是长度固定，可以用下标索引，并且所有的 元素的类型都是一致的。

- 列表

​        列表和数组很相似，只不过它的大小可以改变。列表一般都是通过一个固定大小的 数组来实现的，并且会在需要的时候自动调整大小。列表里可以包含重复的元素。

- 集合

​        集合和列表很相似，不过它不能放重复的元素

- 堆栈

​        堆栈只允许对最后插入的元素进行操作，也就是先进后出。如果你移除了栈顶的元素，那么你可以操作倒数第二个元素，依次类推。这里边常用的方法有peek()返回不删除栈顶元素，push()向栈里添加元素， pop()返回并删除栈顶元素。

- 队列

​        队列和堆栈有些相似，不同之处在于在队列里第一个插入的元素也是第一个被删除 的元素，就是先进先出。常用的方法有peek()返回头部元素，offer()向尾部添加元素， poll() 移除并返回头部元素

- 链表

​        链表是一种由多个节点组成的数据结构，并且每个节点包含有数据以及指向下一个节点的引用，在双向链表里，还会有一个指向前一个节点的引用。例如，可以用单向链表和 双向链表来实现堆栈和队列，因为链表的两端都是可以进行插入和删除的动作的。当然，也 会有在链表的中间频繁插入和删除节点的场景。



#### 2、Java中集合的结构对比

![Java集合结构图](http://zc16.top/image/list.svg?)





#### 3、HashMap底层原理

我先给您说一下我理解的HashMap吧

在jdk1.8之前，底层是通过数组+链表实现的，当我们创建hashmap时会先创建一个数组，当我们用put方法存数据时，先根据key的hashcode值计算出hash值，然后用这个哈希值确定在数组中的位置，再把value值放进去，如果这个位置本来没放东西，就会直接放进去，如果之前就有，就会生成一个链表，把新放入的值放在头部，当用get方法取值时，会先根据key的hashcode值计算出hash值，确定位置，再根据equals方法从该位置上的链表中取出该value值，当容量超过当前容量的0.75倍之后，就会自动扩容为原来容量的2倍。这个0.75就是负载因子。

但是在jdk1.8之后，HashMap 进行了一些修改，最大的不同就是利用了红黑树，所以其由 数组+链表+ 红黑树组成。因为在1.7的时候，这个链表的长度不固定，所以如果key的hashcode重复之后，那么对应的链表的数据的长度就无法控制了，get数据的时间复杂度就取决于链表的长度了，为了提高这一部分的性能，加入了红黑树，如果链表的长度超过8位之后，会将链表转换为红黑树，极大的降低了时间复杂度

HashMap 线程不安全，即任一时刻可以有多个线程同时 写 HashMap，可能会导致数据的不一致。如果需要满足线程安全，可以用 Collections 的 synchronizedMap 方法使 HashMap 具有线程安全的能力，或者使用 ConcurrentHashMap。



#### 4、介绍下ConcurrentHashMap

> 也可以被问成：线程安全的HashMap类有哪些，ConcurrentHashMap如何保证线程安全

ConcurrentHashMap是线程安全的HashMap，内部采用了的"分段锁"策略，ConcurrentHashMap的主干是个Segment数组。Segment 通过继承ReentrantLock 来进行加锁，所以每次需要加锁的操作锁住的是一个 segment，这样只要保证每个 Segment 是线程安全的，也就实现了全局的线程安全。一个Segment就是一个子哈希表，Segment里维护了一个HashEntry数组，默认有16 个 Segment，所以理论上，最多可以同时支持 16 个线程并发写，只要它们的操作分别分布在不同的 Segment 上。





















