1. .net core 和 .net framework 区别

   ```
   1.跨平台（ kestrel ）、不依赖IIS
   2.内置IOC容器（生命周期）、Logger
   3.Middleware 管道模型
   4.配置文件（ settings json ）
   5.支持异步编程
   6.支持web socket和signal IR
   7.开放源码和社区
   ```

2. 用没用过Task(Async await)及实现原理 、与Thread比较

   ```
   async/await 是 C# 5.0 推出的异步代码编程模型，其本质是编译为状态机。只要函数前带上 async，
   就会将函数转换为状态机。
   对于Async void函数由于没有返回值，我们只能使用确切地等待时间来等待，没有任何对象可以供我们监控该异步操作的状态。
   方法体中使用await，方法也必须声明为async，另一个方法调用声明了async的方法，也需要用await，如果不用await，就会立即从被调用方法返回，继续执行后面的代码，而不会等待被调用async方法实际执行完毕再继续执行后面的代码。
   第二个是利用Task.Result来直接获取结果（会阻塞当前线程，慎用！）
   ```

   ```
   当我们使用async方法是，编译器就会生成一个状态机，在方法内部的await会做如下两件事：
   1：执行await表达式
   2：查看等待的方法是否完成
   如果完成，则执行方法中剩余的部分
   如果没有完成，当任务完成后，用回调函数来执行剩余的部分
   ```

   ```
   线程池做的工作主要是控制运行的线程的数量，处理过程中将任务放入队列，然后在线程创建后
   启动这些任务，如果线程数量超过了最大数量超出数量的线程排队等候，等其它线程执行完毕，
   再从队列中取出任务来执行。他的主要特点为：线程复用；控制最大并发数；管理线程。
   ```

3. EF IQueryable

   ```
   1.Expression 表达式树
   2.ElementType 执行后返回类型
   3.Provider 获取实例数据源对应的query provider
   ```

4. GC机制

   ```
   GC的全称是garbage collection，中文名称垃圾回收，是.NET中对内存管理的一种功能。垃圾回收器跟踪并回收托管内存中分配的对象，定期执行垃圾回收以回收分配给没有有效引用的对象的内存。当使用可用内存不能满足内存请求时，GC会自动进行。
     
   在进行垃圾回收时，垃圾回收器会首先搜索内存中的托管对象，然后从托管代码中搜索被引用的对象并标记为有效，接着释放没有被标记为有效的对象并收回内存，最后整理内存将有效对象挪动到一起
   
   Generation 0 : 0代，这里面都是生命周期很短的对象，比如临时变量，当你new一个对象的时候该对象都会在 Generation 0 中，这里的对象将很快的被GC回收，但是当你new的是一个大对象的时候它会直接进去大对象堆(LOH)
   Generation 1 : 1代，这一代包含的也基本是生命周期很短的对象。它是短期对象和长期对象之间的缓冲区。
   Generation 2 : 2代，这一代包含的都是生命周期长的对象，它们都是从1代和2代中选拔出来的， LOH 属于2代。
   
   回收开始时 GC 会开始循环遍历 Generation 0 中的所有对象并标记所有对象是活动对象还是非活动对象，标记完成后会更新活动对象的引用。最后会回收非活动对象占用的内存，并把活动对象压缩后移动到 Generation 1 中， Generation 1 中的或对象在移动到 Generation 2 是默认不会被压缩的，因为复制大的对象会导致性能的下降。可以通过 GCSettings.LargeObjectHeapCompactionMode 来配置压缩 LOH 。
   
   ```

   ```
   理解垃圾回收的基本工作原理
   文件、内存缓冲区、屏幕空间、网络连接数、数据库资源等都是要分配内存的。
   垃圾回收实在第0代慢的时候发生的。0带式最新分配的
   垃圾回收后0代幸存者升致1代，1代幸存升到2代，第0代被空出来，迎接新对象的到来。
   CLR的托管堆只支持三代（0 256kb，1 2mb，2 10mb）
   释放资源 Finalize dispose close
   ```

5. 类里面初始化顺序

   ```
   1.常量（不变化的值必须在编译时确定）、只读字段(只能构造函数)、静态字段
   2.静态构造函数
   3.实例构造器
   4.实例方法和静态方法
   5.实例属性
   6.实例有参属性[索引器]
   7.实例事件
   ```

6. 为什么第一次执行比较慢?

   ```
   1.源代码（cs等文件）--->编译为IL代码，双击exe文件，CLR程序自动启动，加载exe文件，并根据引用情况，加载dll文件
   找到主入口main方法，即时将IL代码编译为机器代码，执行，根据引用的情况，不断的加载IL代码，编译为机器代码，执行，执行完了以后不会把编译好的代码清除出内存，下载直接用。
   2.Ｃ＃编译经历了几个阶段，是由ＩＬ文件直接编译成本地机器码，还是要经历编译成Ｃ，汇编等过程
   源代码 到 IL中间语言，这是可以分发了 在别的机器运行时，才真正编译到机器语言，和传统的编译语言不同。
   编译器从来都不会编译为c，汇编等语言的吧
   ```

7. 堆与栈：相同点和不同点

 ```
在 C#（以及编程和计算机科学领域）中，**堆（Heap）** 和 **栈（Stack）** 是两种核心的内存管理机制。它们在内存分配、数据存储和使用方式上既有相同点，也有显著的不同点。以下是详细说明：  
- **栈** 是一种后进先出（LIFO）的数据结构，存储值类型数据本身（如 `int`、`bool`）和引用类型的地址，生命周期短暂且与函数作用域绑定，分配释放速度快，无需垃圾回收。  
- **堆** 是一个动态分配的内存区域，存储引用类型的对象数据（如类的实例），生命周期由引用决定，分配较慢且依赖垃圾回收器管理。  
- 栈大小固定且较小（默认 1MB），堆受可用内存限制，可存储大量数据。  
- 栈适合小型、临时数据；堆适合大型、动态对象。

## 一、相同点

1. **内存管理的基础设施**  
   - 堆和栈都是程序运行时管理的内存区域，由操作系统和运行时环境（如 .NET CLR）控制。  
   - 两者都用于存储程序运行时的数据。  

2. **动态分配**  
   - 在 C# 中，堆和栈的内存分配由 CLR 自动管理，开发者无需手动干预（不像 C/C++ 需要显式操作）。  

3. **线程相关性**  
   - 每个线程有独立的栈，用于存储函数调用和局部变量；堆则是线程共享的，但两者都支持线程的执行需求。  

## 二、不同点

以下从多个维度对比堆和栈：

### 1. 定义和作用

- **栈（Stack）**  
  - 栈是一种 **后进先出（LIFO, Last In First Out）** 的数据结构，主要管理函数调用和局部变量。  
  - 存储 **值类型（Value Types）**（如 `int`、`float`、`struct`）和 **引用类型的引用（Reference Pointers）**。  
  - 内存分配和释放由编译器在编译时静态确定，运行时按函数调用顺序自动管理。  

- **堆（Heap）**  
  - 堆是一个动态分配的内存区域，用于存储 **引用类型（Reference Types）** 的对象实例（如 `class`、`string`、`array`）。  
  - 内存分配在运行时动态进行，由垃圾回收器（Garbage Collector, GC）管理。  

### 2. 内存分配方式

- **栈**  
  - 分配和释放是连续的、线性的，遵循函数调用生命周期。  
  - 函数结束时，栈帧（Stack Frame）自动弹出，内存立即释放，无需额外管理。  
  - 示例：  
    ```csharp
    void Method()
    {
        int x = 10; // 存储在栈上
    } // 函数结束，x 自动从栈中移除
  ```

 8. 64位架构标准名称的混淆与 CPU 架构的详细解释
  ```
在计算机领域，64 位架构的命名确实存在不少混淆，尤其是 **x86-64**、**EM64T**（后更名为 Intel 64）和 **AMD64** 这几个术语经常被交叉使用。这些名称虽然指向相似的概念，但背后有不同的历史、技术细节和厂商背景。以下将详细解释这些术语的由来、区别以及 CPU 架构的演变，帮助澄清混淆。

## 一、背景与历史

### 1. x86 架构的起源
- **x86** 是一个由 Intel 在 1978 年推出的 16 位指令集架构（ISA），最初用于 8086 处理器。
- 随着技术发展，x86 在 1985 年（80386 处理器）扩展到 32 位，成为主流的桌面和服务器 CPU 架构，称为 **IA-32**（Intel Architecture 32-bit）。
- 然而，32 位架构的局限性逐渐显现，尤其是内存寻址能力受限于 4GB（2^32 字节），无法满足高性能计算、服务器和现代应用程序的需求。

### 2. 64 位需求的兴起
- 到 1990 年代末，业界认识到需要 64 位架构来扩展内存寻址（理论上可达 16EB，即 2^64 字节）和提升性能。
- Intel 最初尝试推出全新的 64 位架构 **IA-64**（与 HP 合作开发的 Itanium），但它完全抛弃了对 x86 的兼容性，采用 VLIW（超长指令字）设计。由于性能问题和软件生态的缺失，IA-64 未能在消费市场成功。
- 与此同时，AMD 采取了不同的策略，基于 x86 扩展出一个向后兼容的 64 位架构，这就是后来的 **AMD64**。

### 3. AMD64 的诞生
- 1999 年，AMD 开始设计 **x86-64**（后来命名为 AMD64），并于 2003 年在 Opteron 和 Athlon 64 处理器中首次实现。
- AMD64 的核心理念是扩展 x86 的 32 位指令集到 64 位，同时保留对 16 位和 32 位代码的原生支持，确保现有软件无需修改即可运行。
- 这一架构迅速获得了市场认可，成为 64 位计算的标准。

### 4. Intel 的回应：EM64T / Intel 64
- Intel 最初对 AMD 的 64 位扩展持怀疑态度，坚持推广 IA-64。但面对 AMD64 的成功和市场压力，Intel 在 2004 年推出了 **EM64T**（Extended Memory 64-bit Technology），作为对 AMD64 的回应。
- EM64T 最早出现在 Pentium 4 的 Prescott 核心和 Xeon 的 Nocona 核心中，后更名为 **Intel 64**。
- Intel 64 在很大程度上兼容 AMD64，但存在一些细微差异（详见下文）。

---

## 二、术语的含义与混淆来源

### 1. x86-64
- **定义**：x86-64 是 64 位架构的通用名称，表示基于 x86 的 64 位扩展。它最初由 AMD 提出（早期文档中称为 x86-64），后来成为行业标准术语。
- **混淆来源**：x86-64 是一个中立的学术和技术术语，不绑定特定厂商，因此被广泛用于描述 AMD 和 Intel 的 64 位实现。但在具体场景中，人们可能会用 AMD64 或 Intel 64 来强调厂商。

### 2. AMD64
- **定义**：AMD64 是 AMD 对其 64 位架构的官方命名，强调这是 AMD 主导的创新。它与 x86-64 在技术上等价，但带有品牌烙印。
- **混淆来源**：由于 AMD 是 64 位 x86 扩展的先驱，许多操作系统（如 Linux 和 FreeBSD）早期将 64 位架构命名为 “amd64”，即使运行在 Intel CPU 上。这种命名惯性导致人们误以为 AMD64 仅适用于 AMD 处理器。

### 3. EM64T / Intel 64
- **定义**：EM64T 是 Intel 最初对其 64 位实现的命名，后改为 **Intel 64**。它是对 AMD64 的直接借鉴，但在早期实现中缺少一些特性（如 NX 位）。
- **混淆来源**：Intel 曾使用多个名称（如 IA-32e、EM64T），最终定为 Intel 64。这种命名变化加上与 AMD64 的相似性，让人难以区分两者。

### 4. 交叉使用的根源
- **技术相似性**：AMD64 和 Intel 64 的指令集高度兼容，软件通常无需针对两者单独编译，导致术语混用。
- **市场与生态**：微软使用 **x64** 作为中性术语（如 Windows x64 Edition），进一步模糊了厂商界限。
- **历史惯性**：早期文档和社区（如 Linux 的 “amd64” 发行版）沿用 AMD64，导致名称交叉使用。

---

## 三、x86-64（AMD64 / Intel 64）的技术细节

### 1. 核心特性
- **64 位寄存器**：通用寄存器从 32 位扩展到 64 位（如 EAX 变为 RAX），数量从 8 个增加到 16 个，提升了性能和编译器优化空间。
- **内存寻址**：虚拟地址空间扩展到 64 位（当前实现中通常为 48 位，即 256TB），物理地址空间从 36 位（64GB）扩展到 52 位（4PB）。
- **向后兼容**：支持 “长模式”（Long Mode），包括 64 位模式和兼容模式（运行 32 位和 16 位代码），以及 “传统模式”（Legacy Mode）运行纯 32 位系统。
- **新指令**：引入 REX 前缀支持扩展寄存器，新增 RIP 相对寻址（优化位置无关代码）。

### 2. 运行模式
- **长模式（Long Mode）**：
  - **64 位模式**：运行原生 64 位操作系统和应用程序，使用全部 64 位功能。
  - **兼容模式**：在 64 位 OS 下运行 32 位或 16 位程序。
- **传统模式（Legacy Mode）**：运行 32 位或 16 位操作系统，禁用 64 位功能。

### 3. 关键改进
- **更多寄存器**：减少内存访问，提升计算效率。
- **SSE/SSE2**：AMD64 强制支持 SSE 和 SSE2 指令集（浮点运算），Intel 64 后来也跟进。
- **NX 位**：No-Execute 位，增强安全性，防止缓冲区溢出攻击（AMD 较早实现，Intel 早期缺失）。

---

## 四、AMD64 与 Intel 64 的差异

尽管两者高度兼容，仍有一些技术细节上的区别：

### 1. 早期特性支持
- **NX 位**：AMD64 从一开始支持，Intel 64 在 Pentium 4 的 E0 步进（2004 年 10 月）才加入。
- **CMPXCHG16B**：AMD64 早期处理器（Revision F 之前）缺少此指令，Intel 64 普遍支持。

### 2. 寄存器行为
- **BSF/BSR 指令**：在操作数为 0 且 32 位时，AMD64 和 Intel 64 的行为不同（Intel 清空高 32 位，AMD 不清空）。
- **微码更新**：AMD64 和 Intel 64 使用不同格式的微码更新机制。

### 3. 内存管理
- **IO-MMU**：AMD64 支持 AGP 孔径作为 IO-MMU，允许 PCI 设备直接访问超过 4GB 的内存；Intel 64 早期依赖反弹缓冲区（较慢），后来通过 VT-d 技术弥补。
- **物理地址空间**：AMD 在 2007 年（Opteron 10h）率先支持 48 位物理寻址，Intel 在 2010 年（Nehalem-EX）跟进。

### 4. 指令序列化
- **LFENCE/MFENCE**：AMD64 和 Intel 64 对这些指令的序列化行为不同（AMD 更严格，Intel 更宽松）。
- **SYSCALL/SYSRET**：Intel 64 仅在 IA-32e 模式支持，AMD64 支持更广。

---

## 五、现代演进

- **x86-64 版本**：2020 年，AMD、Intel、红帽和 SUSE 合作定义了 x86-64 的微架构级别（v1 到 v4），新增指令如 AVX、AVX2、AVX512，提升并行计算能力。
- **ARM64 的竞争**：ARM 的 64 位架构（AArch64）近年来崛起，凭借低功耗和高性能挑战 x86-64，但在桌面和服务器领域，x86-64 仍占主导。

---

## 六、总结表

| 术语       | 定义                              | 厂商    | 备注                          |
|------------|-----------------------------------|---------|-------------------------------|
| x86-64     | 通用名称，64 位 x86 扩展          | 中立    | 学术和技术标准术语            |
| AMD64      | AMD 的 64 位架构实现              | AMD     | 先驱，广泛用于 OS 命名        |
| EM64T      | Intel 早期的 64 位实现            | Intel   | 已更名为 Intel 64             |
| Intel 64   | Intel 当前的 64 位实现            | Intel   | 与 AMD64 高度兼容但有细微差异 |

---

## 七、结语

x86-64、AMD64 和 Intel 64 的混淆源于历史发展和市场竞争。AMD64 是这场变革的起点，Intel 64 是其追随者，而 x86-64 则是统一的技术标签。理解这些术语的关键在于区分它们的背景和技术细节，同时认识到它们在现代计算中的高度兼容性。希望这篇解释能帮助你理清这些概念！
  ```