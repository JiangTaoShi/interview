1. .net core 和 .net framework 区别

   ```
   1.跨平台（ kestrel ）、不依赖IIS
   2.内置IOC容器（生命周期）、Logger
   3.Middleware 管道模型
   4.配置文件（ settings json ）
   5.支持异步编程
   6.支持web socket和signal IR
   7.开放源码和社区
   ```

2. 用没用过Task(Async await)及实现原理 、与Thread比较

   ```
   async/await 是 C# 5.0 推出的异步代码编程模型，其本质是编译为状态机。只要函数前带上 async，
   就会将函数转换为状态机。
   对于Async void函数由于没有返回值，我们只能使用确切地等待时间来等待，没有任何对象可以供我们监控该异步操作的状态。
   方法体中使用await，方法也必须声明为async，另一个方法调用声明了async的方法，也需要用await，如果不用await，就会立即从被调用方法返回，继续执行后面的代码，而不会等待被调用async方法实际执行完毕再继续执行后面的代码。
   第二个是利用Task.Result来直接获取结果（会阻塞当前线程，慎用！）
   ```

   ```
   当我们使用async方法是，编译器就会生成一个状态机，在方法内部的await会做如下两件事：
   1：执行await表达式
   2：查看等待的方法是否完成
   如果完成，则执行方法中剩余的部分
   如果没有完成，当任务完成后，用回调函数来执行剩余的部分
   ```

   ```
   线程池做的工作主要是控制运行的线程的数量，处理过程中将任务放入队列，然后在线程创建后
   启动这些任务，如果线程数量超过了最大数量超出数量的线程排队等候，等其它线程执行完毕，
   再从队列中取出任务来执行。他的主要特点为：线程复用；控制最大并发数；管理线程。
   ```

3. EF IQueryable

   ```
   1.Expression 表达式树
   2.ElementType 执行后返回类型
   3.Provider 获取实例数据源对应的query provider
   ```

4. GC机制

   ```
   GC的全称是garbage collection，中文名称垃圾回收，是.NET中对内存管理的一种功能。垃圾回收器跟踪并回收托管内存中分配的对象，定期执行垃圾回收以回收分配给没有有效引用的对象的内存。当使用可用内存不能满足内存请求时，GC会自动进行。
     
   在进行垃圾回收时，垃圾回收器会首先搜索内存中的托管对象，然后从托管代码中搜索被引用的对象并标记为有效，接着释放没有被标记为有效的对象并收回内存，最后整理内存将有效对象挪动到一起
   
   Generation 0 : 0代，这里面都是生命周期很短的对象，比如临时变量，当你new一个对象的时候该对象都会在 Generation 0 中，这里的对象将很快的被GC回收，但是当你new的是一个大对象的时候它会直接进去大对象堆(LOH)
   Generation 1 : 1代，这一代包含的也基本是生命周期很短的对象。它是短期对象和长期对象之间的缓冲区。
   Generation 2 : 2代，这一代包含的都是生命周期长的对象，它们都是从1代和2代中选拔出来的， LOH 属于2代。
   
   回收开始时 GC 会开始循环遍历 Generation 0 中的所有对象并标记所有对象是活动对象还是非活动对象，标记完成后会更新活动对象的引用。最后会回收非活动对象占用的内存，并把活动对象压缩后移动到 Generation 1 中， Generation 1 中的或对象在移动到 Generation 2 是默认不会被压缩的，因为复制大的对象会导致性能的下降。可以通过 GCSettings.LargeObjectHeapCompactionMode 来配置压缩 LOH 。
   
   ```

   ```
   理解垃圾回收的基本工作原理
   文件、内存缓冲区、屏幕空间、网络连接数、数据库资源等都是要分配内存的。
   垃圾回收实在第0代慢的时候发生的。0带式最新分配的
   垃圾回收后0代幸存者升致1代，1代幸存升到2代，第0代被空出来，迎接新对象的到来。
   CLR的托管堆只支持三代（0 256kb，1 2mb，2 10mb）
   释放资源 Finalize dispose close
   ```

5. 类里面初始化顺序

   ```
   1.常量（不变化的值必须在编译时确定）、只读字段(只能构造函数)、静态字段
   2.静态构造函数
   3.实例构造器
   4.实例方法和静态方法
   5.实例属性
   6.实例有参属性[索引器]
   7.实例事件
   ```

6. 为什么第一次执行比较慢?

   ```
   1.源代码（cs等文件）--->编译为IL代码，双击exe文件，CLR程序自动启动，加载exe文件，并根据引用情况，加载dll文件
   找到主入口main方法，即时将IL代码编译为机器代码，执行，根据引用的情况，不断的加载IL代码，编译为机器代码，执行，执行完了以后不会把编译好的代码清除出内存，下载直接用。
   2.Ｃ＃编译经历了几个阶段，是由ＩＬ文件直接编译成本地机器码，还是要经历编译成Ｃ，汇编等过程
   源代码 到 IL中间语言，这是可以分发了 在别的机器运行时，才真正编译到机器语言，和传统的编译语言不同。
   编译器从来都不会编译为c，汇编等语言的吧
   ```